## Vite速度快且更优的原因

## 1.原生ESM与按需编译（开发环境的核心） -> 冷启动快
- 传统工具（如webpack）的瓶颈：启动开发服务器时，需要打包整个应用（包括所有依赖和源码）。生成一个或多个大的bundle，随着项目变大，启动和重载变得极其缓慢。
- Vite的解决方案
  - **基于原生ESM**：Vite的开发服务器直接将源代码以原生ES模块的形式提供给浏览器。浏览器自己负责解析模块依赖图。
  - **按需编译**：Vite不会预先打包整个应用。它启动一个轻量级的开发服务器，只在浏览器真正请求某个模块时菜按需编译该模块，这带来：
  - - **极致的启动速度。**服务器启动几乎瞬间完成，因为只需要启动服务器，不需要处理任何编译。
  - - **按需编译** 只有被请求的模块会被编译，避免了处理未使用代码的开销。
  - - **高效的缓存** 编译后的模块会被强缓存。依赖模块（通过预构建）会被强缓存。

## 2.依赖预构建（开发环境优化）-> 依赖加载快
- 问题：第三方依赖（通常是CommonJS或者UMD格式），或者包含大量小文件）不适合直接以ESM形式加载，会拖慢速度。
- vite的解决方案：
  - 预构建：Vite在首次启动后依赖变更后，使用esbuild（go编写）将依赖预构建成少量高性能的esm模块。
  - 优势
  - - 解决兼容性：CJS/UMD转化为ESM
  - - 性能提升：合并少量文件、减少HTTP请求数量（解决“海量”模块问题）
  - - 强缓存：构建结果存储在`node_modules/.vite`中，基于内容哈希进行强缓存，依赖不变则无需重新构建。

## 3.极致的HMR -> 更新快
- 传统工具：HMR时，需要重新构建受影响的部分（有时是整个chunk甚至应用），速度随项目增大而变慢
- Vite的解决方案：
- - 基于原生ESM：当文件修改，Vite只需要精确地使修改模块及其直接依赖HMR边界失效。
- - HMR API集成
- - 优势：无论项目大小，HMR更新都保持快速恒定，通常只需几毫米到几十毫秒

