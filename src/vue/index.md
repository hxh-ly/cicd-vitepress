## 谈谈对composition api对理解
理解Composition API，关键在于明白它解决了什么问题，它的核心思想是什么以及它带来什么优势？
### 核心思想与定位：
**逻辑关注点分离**。Composition Api的核心设计理念是基于逻辑（而不是选项类型）来组织代码。 vue2的options API 一个功能代码（如数据data、方法methods、计算属性computed、生命周期钩子mounted）会被分散在不同的选项块中，当组件变得复杂时，理解和维护一个功能的完整逻辑需要在这些分散的块之间来回跳转。这被称为“碎片化”

**函数式组合**。Composition API提供了一套函数式的API（如ref、reactive、computed、watch、onMounted），像编写普通js函数一样，按功能逻辑将这些API组合（Compose）在一起。每个功能相关的所有代码（状态、逻辑、副作用）都紧密组织在在一个代码块或一个单独的函数中。

### 解决的核心的问题
- **Options API在复杂组件中的维护性问题**：随着组件功能增多，分散在多个选项块导致 **阅读困难、维护困难、逻辑复用局限**
- **更好的TypeScript集成**
- **更灵活的逻辑复用**：Composition API**将使得组件逻辑提取和复用变得极其简单和灵活**。比mixins（命名冲突、来源明确）更清晰；比高阶组件更轻量（避免嵌套）

### 主要优势
- 代码组织更优
- 逻辑复用强大且灵活
- 更好的TypeScript支持

## mixins的核心局限性
- **命名冲突风险（隐式合并）**。问题，多个同名属性/方法时，vue的合并策略会覆盖或合并，编译无警告。
- **隐藏依赖关系（“黑盒”逻辑）**。问题：mixin内部可能依赖组件的特定属性/方法，但无显示声明。
```js
export default {
    mounted() {
        this.fetchUser(); // 要求组件必需实现
    }
}
```
- **逻辑碎片化。**问题：单个功能被拆分到多个选项块中。随着组件复杂度提升，维护、阅读困难。
- **复用性受限**。 问题：mixin时**静态**合并到组件中去的，无法根据条件动态组合。
```js
// 静态无法按需加载
mixins:[MixinA,MixinB,MixinC]
```
- **全局mixin的污染风险**
```js
Vue.mixin({
    created(){ console.log('全局污染')}
})
```
- **调试困难（来源不明）**。组件中使用的属性/方法无法追溯来源
- **TypeScript支持弱**。mixin注入的属性和方法缺乏类型推导。

### 关键结论
1. mixin是平面化的合并。多个mixin像图层叠加，易产生冲突和隐式耦合。
2. composition API是 “积木式”组合：通过函数组合显示连接逻辑，保留独立性和可追溯性。
3. 设计哲学差异。mixin是关注“注入功能”。Composition关注“如何组织功能”。